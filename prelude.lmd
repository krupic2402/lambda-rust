let I = (Lx.x)
let K = (Lx.(Ly.x))
let S = (Lx.(Ly.(Lz.(x z (y z)))))
let 0 = (K I)
let F = 0
let T = K
let true = T
let false = F
let if = (Li.(Lt.(Le.(i t e))))
let and = (Lp.(Lq.(p q p)))
let or = (Lp.(Lq.(p p q)))
let not = (Lp.(p F T))
let succ = (Ln.(Lf.(Lx.(f (n f x)))))
let 1 = (succ 0)
let plus = (La.(Lb.(a succ b)))
let mult = (La.(Lb.(a (plus b) 0)))
let pow = (La.(Lb.(b a)))
let Y = (Lg.((Lx.(g (x x))) (Lx.(g (x x)))))
let fix = Y
let is0 = (Lz.(z (K F) T))
let pair = (La.(Lb.(Lf.(f a b))))
let ap = (Lf.(Lp.(p f)))
let fst = (ap T)
let snd = (ap F)
let pred = (Ln.(fst (n (Lp.(pair (snd p) (succ (snd p)))) (pair 0 0))))
let sub = (La.(Lb.(b pred a)))
let leq = (La.(Lb.(is0 (sub a b))))
let eq = (La.(Lb.(and (leq a b) (leq b a))))
let less = (La.(Lb.(and (leq a b) (not (eq a b)))))
let dm = (Lr.(Ln.(Ld.(if (less n d) (pair 0 n) ((r (sub n d) d) (Lq.(Lr.(pair (succ q) r))))))))
let divmod = (La.(Lb.(if (is0 b) error (fix dm a b))))
let div = (La.(Lb.(fst (divmod a b))))
let mod = (La.(Lb.(snd (divmod a b))))
let fact = (fix (Lr.(Ln.(if (is0 n) 1 (mult (r (pred n)) n)))))
let gcd = (fix (Lr.(La.(Lb.(if (is0 b) a (r b (mod a b)))))))
